###### Сравнение сборщиков: Parallel, Serial, G1GC

*Исследования проводились с параметрами виртуальной машины*:<p>
-Xms4096m -Xmx4096m -XX:+HeapDumpOnOutOfMemoryError и последовательно с использованием каждого из трёх сборщиков
<p>Алгоритм постоянно наращивал используемый объём памяти под List с ссылками на объекты, предыдущий List "скармливался" сборщику мусора.
<p>Для чистоты тестирования другие процессы не запускались.
<p>Для анализа использования конкуренции времени потраченного JVM на сборку и выполнение алгоритма решил посчитать соотношение используемого времени на работу алгоритма и сборщика, назвал его ниже "Коэффициент конкуренции", чем он больше - тем больше времени тратила JVM на выполнение алгоритма а не на сборку. 

*Parallel*
<p>Пока объём памяти использовался около 25% сборщик прекрасно справлялся, тратя в среднем на сборку Young около 0.25 ms, после превышения используемого объёма более 75% время сборки резко увеличилось до 730 ms, затем стали запускаться другие алгоритмы сборки, общее время на сборку мусора составило 199 секунд, общее время работы алгоритма до падения с переполнением памяти составило: 04:55 (273 секунды), "Коэффициент конкуренции" - (273 - 199) / 199 = 0.37. При этом время сборки составило: максимальное - 1.4 сек. и среднее - 0.59.   

*Serial*
<p>Пока объём памяти использовался около 25% сборщик прекрасно справлялся, тратя в среднем на сборку Young около 0.5 ms, после превышения используемого объёма более 75% время сборки резко увеличилось до 400 ms, попеременно запускались только два алгоритма сборки: Pause Young и Pause Full, общее время на сборку мусора составило 29 секунд, общее время работы алгоритма до падения с переполнением памяти составило: 01:45 (87 секунд), "Коэффициент конкуренции" - (87 - 29) / 29 = 2. При этом время сборки составило: максимальное - 0.47 сек. и среднее - 0.1.   

*G1*
<p>По логам видно, что сборщик использует многопоточность и различные алгоритмы сборки
общее время работы алгоритма до падения с переполнением памяти составило: 02:29 (149 сек.), На всём протяжении работы сборщик использова время сборки равномерно, даже после критической нехватки памяти в отлиции от Parallel и Serial, которые начинали на "Stop the world" тратить больше времени, видимо сказывается использование многопоточности. "Коэффициент конкуренции" - (149 - 10) / 149 = 0.93. При этом время сборки составило: максимальное - 0.38 сек. и среднее - 0.03.

<table title="Сравнительная таблица">
<tr>
    <th>Сборщик</th>
    <th>Время работы</th>
    <th>Время сборки</th>
    <th>Макс. сборка</th>
    <th>Сред. сборка</th>
</tr>

<tr>
<td>Parallel</td>
<td>273</td>
<td>199</td>
<td>1.40</td>
<td>0.59</td>
</tr>

<tr>
<td>Serial</td>
<td>87</td>
<td>29</td>
<td>0.47</td>
<td>0.10</td>
</tr>

<tr>
<td>G1</td>
<td>149</td>
<td>11</td>
<td>0.38</td>
<td>0.03</td>
</tr>

</table>

<H4>Вывод: Для приложения важно чтобы сборщик делал паузы на сборку (Stop the world) как можно меньше, при этом делал это с максимальной эффективностью. Для данного алгоритма лучшим сборщиком оказался G1. Сборщики Serial и Parallel были эффективны пока память не стала заканчиваться и они приступили к очистке FULL, после этого паузы на сборку стали занимать много времени. G1 до самого падения от нехватки памяти паузы на сборку делал равномерные.    